(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Xavier Leroy, INRIA Paris-Rocquencourt                     *)
(*                                                                     *)
(*  Copyright Institut National de Recherche en Informatique et en     *)
(*  Automatique.  All rights reserved.  This file is distributed       *)
(*  under the terms of the GNU General Public License as published by  *)
(*  the Free Software Foundation, either version 2 of the License, or  *)
(*  (at your option) any later version.  This file is also distributed *)
(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
(*                                                                     *)
(* *********************************************************************)

(** All imports and definitions used by .v Clight files generated by clightgen *)

Require Export String.
Require Export List.
Require Export ZArith.
Require Export Integers.
Require Export Floats.
Require Export AST.
Require Export Ctypes.
Require Export Cop.
Require Export Clight.
Require Import Maps.
Require Import Errors.

Definition tvoid := Tvoid.
Definition tschar := Tint I8 Signed noattr.
Definition tuchar := Tint I8 Unsigned noattr.
Definition tshort := Tint I16 Signed noattr.
Definition tushort := Tint I16 Unsigned noattr.
Definition tint := Tint I32 Signed noattr.
Definition tuint := Tint I32 Unsigned noattr.
Definition tbool := Tint IBool Unsigned noattr.
Definition tlong := Tlong Signed noattr.
Definition tulong := Tlong Unsigned noattr.
Definition tfloat := Tfloat F32 noattr.
Definition tdouble := Tfloat F64 noattr.
Definition tptr (t: type) := Tpointer t noattr.
Definition tarray (t: type) (sz: Z) := Tarray t sz noattr.

Definition volatile_attr := {| attr_volatile := true; attr_alignas := None |}.

Definition tattr (a: attr) (ty: type) :=
  match ty with
  | Tvoid => Tvoid
  | Tint sz si _ => Tint sz si a
  | Tlong si _ => Tlong si a
  | Tfloat sz _ => Tfloat sz a
  | Tpointer elt _ => Tpointer elt a
  | Tarray elt sz _ => Tarray elt sz a
  | Tfunction args res cc => Tfunction args res cc
  | Tstruct id _ => Tstruct id a
  | Tunion id  _ => Tunion id a
  end.

Definition tvolatile (ty: type) := tattr volatile_attr ty.

Definition talignas (n: N) (ty: type) :=
  tattr {| attr_volatile := false; attr_alignas := Some n |} ty.

Definition tvolatile_alignas (n: N) (ty: type) :=
  tattr {| attr_volatile := true; attr_alignas := Some n |} ty.

Definition make_composite_env (comps: list composite_definition): composite_env :=
  match build_composite_env comps with
  | OK e => e
  | Error _ => PTree.empty _
  end.

Definition not_error {A} (x: Errors.res A) : Prop :=
  match x with Errors.Error _ => False | _ => True end.

Lemma not_error_composite_env: forall x,
  not_error (build_composite_env x) ->
 build_composite_env x = Errors.OK (make_composite_env x).
Proof.
 intros.
 unfold make_composite_env.
 destruct (build_composite_env x); auto.
 simpl in H. contradiction H.
Qed.

Lemma not_error_add_composite: 
  forall env id su ms a defs, 
    Maps.PTree.get id env = None ->
    complete_members env ms = true -> 
    (Coqlib.align (sizeof_composite env su ms) (align_attr a (alignof_composite env ms)) >= 0)%Z ->
     not_error (add_composite_definitions 
                (Maps.PTree.set id 
                  {| co_su := su; co_members := ms; co_attr := a; 
                     co_sizeof := Coqlib.align (sizeof_composite env su ms)
                                         (align_attr a (alignof_composite env ms));
                     co_alignof := align_attr a (alignof_composite env ms);
                     co_rank := rank_members env ms;
                     co_sizeof_pos := Ctypes.composite_of_def_obligation_1 env su ms a;
                     co_alignof_two_p := Ctypes.composite_of_def_obligation_2 env ms a;
                     co_sizeof_alignof := Ctypes.composite_of_def_obligation_3 env su ms a |}
                  env) defs) ->
    not_error (add_composite_definitions env (Composite id su ms a :: defs)).
Proof.
intros.
unfold add_composite_definitions; fold add_composite_definitions.
unfold composite_of_def.
rewrite H.
rewrite H0.
unfold Errors.bind.
apply H2.
Qed.

Ltac check_add_composite :=
simple apply not_error_add_composite;
  [reflexivity | reflexivity | compute; intro Hx; inversion Hx | ];
match goal with |- 
  not_error (add_composite_definitions (Maps.PTree.set _ 
         {|  co_members := ?M; co_sizeof := ?S1; co_alignof := ?S2; co_rank := ?S3 |} _) _)  =>
  let s := fresh "s" in
  set (s := S1); compute in s; subst s;
  set (s := S2); compute in s; subst s;
  set (s := S3); compute in s; subst s;
  let m := fresh "m" in set (m:=M)
end;
 simpl Maps.PTree.set;
match goal with |- 
  not_error (add_composite_definitions ?E _) =>
    let e := fresh "e" in set (e:=E)
end.
